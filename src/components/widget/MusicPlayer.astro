---
import { musicPlayerConfig } from "@/config/musicConfig";
import { url } from "@/utils/url-utils";

const config = musicPlayerConfig;

// 预先生成本地资源路径，确保在非根目录部署时也能正确加载
const aplayerCssPath = url("/assets/css/APlayer.min.css");
const aplayerCustomCssPath = url("/assets/css/APlayer.custom.css");
const aplayerJsPath = url("/assets/js/APlayer.min.js");

// MetingJS 路径处理
// 如果配置的是相对路径（以 / 开头），使用 url() 处理以确保非根目录部署时正确
// 如果是完整的 URL（http/https），直接使用
const metingJsPath = config.meting?.jsPath
  ? (config.meting.jsPath.startsWith("http://") || config.meting.jsPath.startsWith("https://"))
    ? config.meting.jsPath
    : url(config.meting.jsPath)
  : "https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"; // 默认 CDN 路径

// 预处理本地音乐列表的路径（如果使用本地模式）
const processedLocalPlaylist = config.mode === "local" && config.local?.playlist
  ? config.local.playlist.map((song) => ({
      ...song,
      url: url(song.url),
      cover: song.cover ? url(song.cover) : undefined,
    }))
  : null;
---

{config.enable && (
  <>
    <!-- APlayer CSS -->
    <link
      rel="stylesheet"
      href={aplayerCssPath}
    />
    <link
      rel="stylesheet"
      href={aplayerCustomCssPath}
    />

    <!-- 音乐播放器容器 -->
    <div
      id="aplayer-container"
      class:mobile-hide={config.responsive?.mobile?.hide}
    >
      {config.mode === "meting" && config.meting ? (
        <!-- 使用 MetingJS -->
        <meting-js
          server={config.meting.server || "netease"}
          type={config.meting.type || "playlist"}
          id={config.meting.id || ""}
          api={config.meting.api}
          auth={config.meting.auth}
          fixed={(config.player?.fixed ?? true) ? "true" : "false"}
          mini={(config.player?.mini ?? true) ? "true" : "false"}
          autoplay={config.player?.autoplay ? "true" : "false"}
          theme={config.player?.theme || "#b7daff"}
          loop={config.player?.loop || "all"}
          order={config.player?.order || "list"}
          preload={config.player?.preload || "auto"}
          volume={String(config.player?.volume ?? 0.7)}
          mutex={config.player?.mutex !== false ? "true" : "false"}
          lrc-type={String(config.player?.lrcType ?? 3)}
          list-folded={config.player?.listFolded ? "true" : "false"}
          list-max-height={config.player?.listMaxHeight || "340px"}
          storage-name={config.player?.storageName || "aplayer-setting"}
        />
      ) : config.mode === "local" && processedLocalPlaylist && processedLocalPlaylist.length > 0 ? (
        <!-- 使用本地音乐列表 -->
        <!-- 单个音乐使用 MetingJS，多个音乐使用 APlayer 直接初始化 -->
        {processedLocalPlaylist.length === 1 ? (
          <meting-js
            name={processedLocalPlaylist?.[0]?.name || ""}
            artist={processedLocalPlaylist?.[0]?.artist || ""}
            url={processedLocalPlaylist?.[0]?.url || ""}
            cover={processedLocalPlaylist?.[0]?.cover}
            fixed={(config.player?.fixed ?? true) ? "true" : "false"}
            mini={(config.player?.mini ?? true) ? "true" : "false"}
            autoplay={config.player?.autoplay ? "true" : "false"}
            theme={config.player?.theme || "#b7daff"}
            loop={config.player?.loop || "all"}
            order={config.player?.order || "list"}
            preload={config.player?.preload || "auto"}
            volume={String(config.player?.volume ?? 0.7)}
            mutex={config.player?.mutex !== false ? "true" : "false"}
            lrc-type={processedLocalPlaylist[0]?.lrc ? "2" : "0"}
            list-folded={config.player?.listFolded ? "true" : "false"}
            list-max-height={config.player?.listMaxHeight || "340px"}
            storage-name={config.player?.storageName || "aplayer-setting"}
          >
            {processedLocalPlaylist?.[0]?.lrc && (
              <pre hidden>
                {processedLocalPlaylist[0].lrc}
              </pre>
            )}
          </meting-js>
        ) : (
          <!-- 多个本地音乐，使用 APlayer 直接初始化 -->
          <div id="local-aplayer"></div>
        )}
      ) : null}
    </div>
  </>
)}

<script define:vars={{ config, aplayerJsPath, metingJsPath, processedLocalPlaylist }} is:inline>
  // 动态加载 APlayer 和 MetingJS
  (function() {
    if (!config.enable) return;
    
    // 确保在浏览器环境中运行
    if (typeof window === 'undefined') return;

    // 加载 APlayer JS
    function loadAPlayer() {
      return new Promise((resolve) => {
        if (window.APlayer) {
          resolve(window.APlayer);
          return;
        }

        const aplayerScript = document.createElement("script");
        aplayerScript.src = aplayerJsPath;
        aplayerScript.async = true;
        aplayerScript.onload = () => resolve(window.APlayer);
        aplayerScript.onerror = () => {
          console.error("Failed to load APlayer");
          resolve(null);
        };
        document.head.appendChild(aplayerScript);
      });
    }

    // 全局用户交互状态
    if (!window.hasMusicInteracted) {
      window.hasMusicInteracted = false;
    }
    
    function tryAutoplay(aplayer) {
      if (!config.player?.autoplay) return;
      
      // 如果用户已经交互过，立即尝试播放
      if (window.hasMusicInteracted) {
        if (aplayer && aplayer.paused) {
          const playPromise = aplayer.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch((error) => {
              // 浏览器阻止自动播放是正常的，不需要报错
              if (error.name !== 'NotAllowedError') {
                console.log('自动播放失败:', error.name);
              }
            });
          }
        }
      } else {
        // 等待用户第一次交互后自动播放
        const enableAutoplay = () => {
          if (window.hasMusicInteracted) return;
          window.hasMusicInteracted = true;
          
          if (aplayer && aplayer.paused) {
            const playPromise = aplayer.play();
            if (playPromise && typeof playPromise.catch === 'function') {
              playPromise.catch((error) => {
                if (error.name !== 'NotAllowedError') {
                  console.log('自动播放失败:', error.name);
                }
              });
            }
          }
        };
        
        // 监听各种用户交互事件（只监听一次）
        ['click', 'keydown', 'touchstart', 'scroll'].forEach(eventType => {
          document.addEventListener(eventType, enableAutoplay, { 
            once: true, 
            passive: true 
          });
        });
      }
    }

    // 检查 MetingJS 元素是否成功加载了音乐
    function checkMetingSuccess(metingElement, timeout = 5000) {
      return new Promise((resolve) => {
        const startTime = Date.now();
        
        const checkSuccess = setInterval(() => {
          const aplayer = metingElement?.aplayer;
          // 检查是否有 APlayer 实例且有音频列表
          if (aplayer && aplayer.list && aplayer.list.audios && aplayer.list.audios.length > 0) {
            clearInterval(checkSuccess);
            resolve(true);
            return;
          }
          
          // 超时检查
          if (Date.now() - startTime >= timeout) {
            clearInterval(checkSuccess);
            resolve(false);
          }
        }, 100);
      });
    }

    // 重新创建 MetingJS 元素以使用新的 API
    function recreateMetingElement(container, apiUrl, config) {
      // 移除旧的元素
      const oldElement = container.querySelector('meting-js');
      if (oldElement) {
        // 如果已有 APlayer 实例，先销毁它
        if (oldElement.aplayer) {
          try {
            oldElement.aplayer.destroy();
          } catch (e) {
            console.warn('销毁旧 APlayer 实例时出错:', e);
          }
        }
        oldElement.remove();
      }
      
      // 创建新元素
      const newElement = document.createElement('meting-js');
      newElement.setAttribute('server', config.meting?.server || 'netease');
      newElement.setAttribute('type', config.meting?.type || 'playlist');
      newElement.setAttribute('id', config.meting?.id || '');
      newElement.setAttribute('api', apiUrl);
      if (config.meting?.auth) {
        newElement.setAttribute('auth', config.meting.auth);
      }
      newElement.setAttribute('fixed', (config.player?.fixed ?? true) ? 'true' : 'false');
      newElement.setAttribute('mini', (config.player?.mini ?? true) ? 'true' : 'false');
      newElement.setAttribute('autoplay', config.player?.autoplay ? 'true' : 'false');
      newElement.setAttribute('theme', config.player?.theme || '#b7daff');
      newElement.setAttribute('loop', config.player?.loop || 'all');
      newElement.setAttribute('order', config.player?.order || 'list');
      newElement.setAttribute('preload', config.player?.preload || 'auto');
      newElement.setAttribute('volume', String(config.player?.volume ?? 0.7));
      newElement.setAttribute('mutex', config.player?.mutex !== false ? 'true' : 'false');
      newElement.setAttribute('lrc-type', String(config.player?.lrcType ?? 3));
      newElement.setAttribute('list-folded', config.player?.listFolded ? 'true' : 'false');
      newElement.setAttribute('list-max-height', config.player?.listMaxHeight || '340px');
      newElement.setAttribute('storage-name', config.player?.storageName || 'aplayer-setting');
      
      container.appendChild(newElement);
      return newElement;
    }

    // 处理移动端显示/隐藏
    function handleMobileVisibility(aplayer) {
      if (!aplayer || !aplayer.container) return;
      
      const shouldHide = config.responsive?.mobile?.hide === true;
      const breakpoint = config.responsive?.mobile?.breakpoint || 768;
      const isMobile = window.innerWidth <= breakpoint;
      
      if (shouldHide && isMobile) {
        aplayer.container.style.display = 'none';
        aplayer.container.classList.add('mobile-hide');
        
        // 同时处理容器（如果存在）
        const container = document.getElementById('aplayer-container');
        if (container) {
          container.style.display = 'none';
          container.classList.add('mobile-hide');
        }
      } else {
        aplayer.container.style.display = '';
        aplayer.container.classList.remove('mobile-hide');
        
        // 同时处理容器（如果存在）
        const container = document.getElementById('aplayer-container');
        if (container) {
          container.style.display = '';
          container.classList.remove('mobile-hide');
        }
      }
    }
    
    // 初始化时处理容器的移动端显示/隐藏
    function initContainerMobileVisibility() {
      const container = document.getElementById('aplayer-container');
      if (!container) return;
      
      const shouldHide = config.responsive?.mobile?.hide === true;
      const breakpoint = config.responsive?.mobile?.breakpoint || 768;
      const isMobile = window.innerWidth <= breakpoint;
      
      if (shouldHide && isMobile) {
        container.style.display = 'none';
        container.classList.add('mobile-hide');
      } else {
        container.style.display = '';
        container.classList.remove('mobile-hide');
      }
      
      // 监听窗口大小变化
      const resizeHandler = () => {
        const nowIsMobile = window.innerWidth <= breakpoint;
        if (shouldHide && nowIsMobile) {
          container.style.display = 'none';
          container.classList.add('mobile-hide');
        } else {
          container.style.display = '';
          container.classList.remove('mobile-hide');
        }
      };
      window.addEventListener('resize', resizeHandler);
    }

    // 初始化 MetingJS 元素并设置播放器
    function setupMetingElement(metingElement) {
      return new Promise((resolve) => {
        // 监听 aplayer 初始化
        const checkAPlayer = setInterval(() => {
          const aplayer = metingElement.aplayer;
          if (aplayer && aplayer.container) {
            clearInterval(checkAPlayer);
            
            // 监听播放状态，更新封面动画
            const updatePlayingState = () => {
              if (aplayer.container) {
                const isPlaying = !aplayer.paused;
                aplayer.container.setAttribute('data-playing', String(isPlaying));
                if (isPlaying) {
                  aplayer.container.classList.add('aplayer-playing');
                } else {
                  aplayer.container.classList.remove('aplayer-playing');
                }
              }
            };
            
            // 监听播放/暂停事件
            if (aplayer.audio) {
              aplayer.audio.addEventListener('play', updatePlayingState);
              aplayer.audio.addEventListener('pause', updatePlayingState);
              aplayer.audio.addEventListener('ended', updatePlayingState);
            }
            
            aplayer.container.setAttribute('data-positioned', 'right');
            // 立即应用右侧样式
            requestAnimationFrame(() => {
              if (aplayer.container) {
                aplayer.container.style.right = '0';
                aplayer.container.style.left = 'unset';
                
                // 初始化播放状态
                updatePlayingState();
                
                // 处理移动端显示/隐藏
                handleMobileVisibility(aplayer);
                
                // 监听窗口大小变化，动态调整显示/隐藏
                const resizeHandler = () => handleMobileVisibility(aplayer);
                window.addEventListener('resize', resizeHandler);
                
                // 短暂延迟后标记为已初始化，恢复展开动画
                setTimeout(() => {
                  aplayer.container.setAttribute('data-initialized', 'true');
                  
                  // 如果配置了默认隐藏歌词，则隐藏歌词
                  if (config.player?.lrcHidden && aplayer.lrc) {
                    aplayer.lrc.hide();
                    // 同时设置歌词按钮为未激活状态
                    const lrcButton = aplayer.container.querySelector('.aplayer-icon-lrc');
                    if (lrcButton) {
                      lrcButton.classList.add('aplayer-icon-lrc-inactivity');
                    }
                  }
                  
                  // 如果自动播放被阻止，等待用户交互后恢复
                  if (config.player?.autoplay && aplayer.paused) {
                    tryAutoplay(aplayer);
                  }
                }, 200);
              }
            });
            
            resolve(true);
          }
        }, 50);
        
        // 10秒后停止检查
        setTimeout(() => {
          clearInterval(checkAPlayer);
          resolve(false);
        }, 10000);
      });
    }

    // 使用备用 API 重试加载
    async function retryWithFallbackAPI(container, fallbackApis, currentIndex = 0) {
      if (currentIndex >= fallbackApis.length) {
        console.error('所有 API 都失败了，无法加载音乐播放器');
        return null;
      }
      
      const fallbackApi = fallbackApis[currentIndex];
      console.log(`尝试使用备用 API ${currentIndex + 1}/${fallbackApis.length}: ${fallbackApi}`);
      
      // 替换 API URL 中的占位符
      const server = config.meting?.server || 'netease';
      const type = config.meting?.type || 'playlist';
      const id = config.meting?.id || '';
      
      let apiUrl = fallbackApi
        .replace(':server', server)
        .replace(':type', type)
        .replace(':id', id);
      
      // 设置全局 API
      window.meting_api = apiUrl;
      
      // 重新创建元素
      const newElement = recreateMetingElement(container, apiUrl, config);
      
      // 等待元素初始化
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // 检查是否成功
      const success = await checkMetingSuccess(newElement, 5000);
      
      if (success) {
        console.log(`备用 API ${currentIndex + 1} 成功加载音乐`);
        return newElement;
      } else {
        // 如果失败，尝试下一个备用 API
        return retryWithFallbackAPI(container, fallbackApis, currentIndex + 1);
      }
    }

    // 加载 MetingJS
    function loadMetingJS() {
      return new Promise((resolve) => {
        if (window.customElements?.get("meting-js")) {
          resolve(true);
          return;
        }

        const metingScript = document.createElement("script");
        metingScript.src = metingJsPath;
        metingScript.async = true;
        metingScript.onload = async () => {
          // 等待 MetingJS 元素创建
          await new Promise(resolve => setTimeout(resolve, 100));
          
          const container = document.getElementById('aplayer-container');
          if (!container) {
            resolve(false);
            return;
          }
          
          let metingElement = container.querySelector('meting-js');
          
          if (config.mode === "meting" && config.meting?.api && metingElement) {
            const server = config.meting.server || 'netease';
            const type = config.meting.type || 'playlist';
            const id = config.meting.id || '';
            
            // 替换 API URL 中的占位符
            let mainApiUrl = config.meting.api
              .replace(':server', server)
              .replace(':type', type)
              .replace(':id', id)
              .replace(':r', Math.random().toString());
            
            // 设置全局 API
            window.meting_api = mainApiUrl;
            
            console.log('尝试使用主 API:', mainApiUrl);
            
            // 等待元素初始化
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 检查主 API 是否成功
            const mainApiSuccess = await checkMetingSuccess(metingElement, 5000);
            
            if (!mainApiSuccess && config.meting.fallbackApis && config.meting.fallbackApis.length > 0) {
              // 主 API 失败，尝试备用 API
              console.warn('主 API 失败，尝试使用备用 API');
              const newElement = await retryWithFallbackAPI(container, config.meting.fallbackApis);
              if (newElement) {
                metingElement = newElement;
              }
            }
          }
          
          // 设置播放器（如果元素存在）
          if (metingElement) {
            await setupMetingElement(metingElement);
          }
          
          resolve(true);
        };
        metingScript.onerror = () => {
          console.error("Failed to load MetingJS");
          resolve(false);
        };
        document.head.appendChild(metingScript);
      });
    }

    // 初始化本地音乐播放器（多个音乐）
    async function initLocalPlayer() {
      if (
        config.mode !== "local" ||
        !processedLocalPlaylist ||
        processedLocalPlaylist.length <= 1
      ) {
        return;
      }

      const APlayerClass = await loadAPlayer();
      if (!APlayerClass) return;

      const container = document.getElementById("local-aplayer");
      if (!container) return;

      // 使用预处理好的路径列表（已经在服务端处理了非根目录部署的问题）
      const audioList = processedLocalPlaylist.map((song) => ({
        name: song.name,
        artist: song.artist,
        url: song.url,
        cover: song.cover,
        lrc: song.lrc || undefined,
        type: "auto",
      }));

      const aplayerOptions = {
        container: container,
        audio: audioList,
        mutex: config.player?.mutex !== false,
        lrcType: config.player?.lrcType !== undefined ? config.player.lrcType : 0,
        fixed: config.player?.fixed ?? true,
        mini: config.player?.mini ?? true,
        autoplay: config.player?.autoplay || false, // 直接设置 autoplay，浏览器可能会阻止但可以后续通过用户交互恢复
        theme: config.player?.theme || "#b7daff",
        loop: config.player?.loop || "all",
        order: config.player?.order || "list",
        preload: config.player?.preload || "auto",
        volume: config.player?.volume || 0.7,
        listFolded: config.player?.listFolded || false,
        listMaxHeight: config.player?.listMaxHeight || "340px",
        storageName: config.player?.storageName || "aplayer-setting",
      };

      try {
        const aplayer = new APlayerClass(aplayerOptions);
        
        // 监听播放状态，更新封面动画
        const updatePlayingState = () => {
          if (aplayer.container) {
            const isPlaying = !aplayer.paused;
            aplayer.container.setAttribute('data-playing', String(isPlaying));
            if (isPlaying) {
              aplayer.container.classList.add('aplayer-playing');
            } else {
              aplayer.container.classList.remove('aplayer-playing');
            }
          }
        };
        
        // 监听播放/暂停事件
        if (aplayer.audio) {
          aplayer.audio.addEventListener('play', updatePlayingState);
          aplayer.audio.addEventListener('pause', updatePlayingState);
          aplayer.audio.addEventListener('ended', updatePlayingState);
        }
        
              // 立即设置右侧定位，避免动画
              if (aplayer.container) {
                aplayer.container.setAttribute('data-positioned', 'right');
                // 确保立即应用右侧样式，避免从左到右的过渡
                requestAnimationFrame(() => {
                  if (aplayer.container) {
                    aplayer.container.style.right = '0';
                    aplayer.container.style.left = 'unset';
                    
                    // 初始化播放状态
                    updatePlayingState();
                    
                    // 处理移动端显示/隐藏
                    handleMobileVisibility(aplayer);
                    
                    // 监听窗口大小变化，动态调整显示/隐藏
                    const resizeHandler = () => handleMobileVisibility(aplayer);
                    window.addEventListener('resize', resizeHandler);
                    
                    // 短暂延迟后标记为已初始化，恢复展开动画
                    setTimeout(() => {
                      aplayer.container.setAttribute('data-initialized', 'true');
                      
                      // 如果配置了默认隐藏歌词，则隐藏歌词
                      if (config.player?.lrcHidden && aplayer.lrc) {
                        aplayer.lrc.hide();
                        // 同时设置歌词按钮为未激活状态
                        const lrcButton = aplayer.container.querySelector('.aplayer-icon-lrc');
                        if (lrcButton) {
                          lrcButton.classList.add('aplayer-icon-lrc-inactivity');
                        }
                      }
                      
                      // 如果自动播放被阻止，等待用户交互后恢复
                      if (config.player?.autoplay && aplayer.paused) {
                        tryAutoplay(aplayer);
                      }
                    }, 100);
                  }
                });
              }
      } catch (error) {
        console.error("Failed to initialize APlayer:", error);
      }
    }

    // 初始化容器的移动端显示/隐藏
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initContainerMobileVisibility);
    } else {
      initContainerMobileVisibility();
    }
    
    // 如果使用 Meting 模式，加载 MetingJS
    if (config.mode === "meting") {
      loadAPlayer().then(() => {
        loadMetingJS();
      });
    } else if (config.mode === "local") {
      // 本地模式：单个音乐使用 MetingJS，多个音乐使用 APlayer
      if (processedLocalPlaylist && processedLocalPlaylist.length > 1) {
        // 多个音乐，使用 APlayer
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", initLocalPlayer);
        } else {
          initLocalPlayer();
        }
      } else {
        // 单个音乐，使用 MetingJS
        loadAPlayer().then(() => {
          loadMetingJS();
        });
      }
    }
  })();
</script>

<style>
  #aplayer-container {
    position: relative;
    z-index: 1000;
  }

  /* 确保播放器在固定模式下正确显示 */
  #aplayer-container .aplayer-fixed {
    z-index: 9999;
  }

  /* 禁用 APlayer 初始化时的过渡动画，避免收缩效果 */
  #aplayer-container .aplayer.aplayer-fixed {
    animation: none !important;
  }
  
  #aplayer-container .aplayer.aplayer-fixed .aplayer-body {
    animation: none !important;
    transition: none !important;
  }
  
  /* 确保播放器初始化时就在右侧位置 */
  #aplayer-container .aplayer.aplayer-fixed[data-positioned="right"] {
    right: 0 !important;
    left: unset !important;
  }

  /* 移动端隐藏 - 通过 JavaScript 动态添加类 */
  .aplayer-fixed.mobile-hide {
    display: none !important;
  }
  
  /* 移动端隐藏容器 */
  #aplayer-container.mobile-hide {
    display: none !important;
  }
</style>

